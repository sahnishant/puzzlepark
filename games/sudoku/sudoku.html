// Example Sudoku grid (0 represents an empty cell)
const initialGrid = [
     [5, 3, 4, 6, 7, 8, 9, 1, 2],
     [6, 7, 2, 1, 9, 5, 3, 4, 8],
     [1, 9, 8, 3, 4, 2, 5, 6, 7],
     [8, 5, 9, 7, 6, 1, 4, 2, 3],
     [4, 2, 6, 8, 5, 3, 7, 9, 1],
     [7, 1, 3, 9, 2, 4, 8, 5, 6],
     [9, 6, 1, 5, 3, 7, 2, 8, 4],
     [2, 8, 7, 4, 1, 9, 6, 3, 5],
     [3, 4, 5, 2, 8, 6, 1, 7, 9],
     ];

         class Sudoku {
         constructor(grid) {
             this.grid = grid; // 2D array representing the board
             this.initialGrid = grid.map(row => [...row]); // Save the original state for resetting
             this.rows = Array(9).fill().map(() => []);
             this.cols = Array(9).fill().map(() => []);
             this.boxes = Array(9).fill().map(() => []);

             // Pre-fill cells in rows, cols, and boxes
             for (let r = 0; r < 9; r++) {
                 for (let c = 0; c < 9; c++) {
                     const value = this.grid[r][c];
                     if(value !== 0) {
                     this.rows[r].push(value);
                     this.cols[c].push(value);
                     this.boxes[this.getBoxIndex(r,c)].push(value)
                     }
                 }
             }
         }

         getBoxIndex(row, col) {
             return Math.floor(row / 3) * 3 + Math.floor(col / 3);
         }


         isValidMove(row, col, value) {
             if(this.rows[row].includes(value) || this.cols[col].includes(value) || this.boxes[this.getBoxIndex(row, col)].includes(value)) {
                 return false;
             }
             return true;
         }

         makeMove(row, col, value) {
             if(!this.isValidMove(row, col, value)) {
               return false; // Invalid Move
             }

             this.grid[row][col] = value;
             this.rows[row].push(value);
             this.cols[col].push(value);
             this.boxes[this.getBoxIndex(row,col)].push(value);
            return true; // Successful move
         }

          clearMove(row, col, value) {
               this.grid[row][col] = 0;
              this.rows[row] = this.rows[row].filter(v => v !== value);
               this.cols[col] = this.cols[col].filter(v => v !== value);
               this.boxes[this.getBoxIndex(row,col)] = this.boxes[this.getBoxIndex(row,col)].filter(v => v !== value);
         }

          isSolved() {
             for(let r = 0; r < 9; r++) {
             for(let c = 0; c < 9; c++){
                 if(this.grid[r][c] === 0) {
                 return false
                 }
             }
             }

             for (let i = 0; i < 9; i++) {
             if (new Set(this.rows[i]).size !== 9 ||
                 new Set(this.cols[i]).size !== 9 ||
                 new Set(this.boxes[i]).size !== 9) {
                 return false; // Duplicates in rows, cols, or boxes
             }
             }
             return true;
         }

          reset() {
              this.grid = this.initialGrid.map(row => [...row]);
              this.rows = Array(9).fill().map(() => []);
             this.cols = Array(9).fill().map(() => []);
             this.boxes = Array(9).fill().map(() => []);
             // Pre-fill cells in rows, cols, and boxes
             for (let r = 0; r < 9; r++) {
                 for (let c = 0; c < 9; c++) {
                     const value = this.grid[r][c];
                     if(value !== 0) {
                         this.rows[r].push(value);
                         this.cols[c].push(value);
                         this.boxes[this.getBoxIndex(r,c)].push(value)
                     }
                 }
             }
         }
     }
 const game = new Sudoku(initialGrid);
     const container = document.getElementById('sudoku-container');
      const messageContainer = document.getElementById('message');
       let selectedCell = null;

      function renderSudoku() {
          container.innerHTML = '';
           const gridDiv = document.createElement('div');
           gridDiv.classList.add('sudoku-grid');
             for (let row = 0; row < 9; row++) {
              for (let col = 0; col < 9; col++) {
               const cellValue = game.grid[row][col];
               const cellDiv = document.createElement('div');
                 if((row + 1) % 3 === 0 && (col+1) % 3 === 0 ||
                 (row + 1) % 3 === 0 && (col) % 3 === 0 ||
                 (row) % 3 === 0 && (col+1) % 3 === 0 ||
                 (row) % 3 === 0 && (col) % 3 === 0) {
                   cellDiv.classList.add('box');
                 }

              if(cellValue === 0) {
                  const input = document.createElement('input');
                  input.type = 'number';
                  input.min = 1;
                  input.max = 9;
                  input.addEventListener('focus', () => {
                      selectedCell = {row, col};
                  })
                   input.addEventListener('input', (e) => handleInput(e, row, col));
                cellDiv.appendChild(input);
              } else {
                cellDiv.textContent = cellValue;
              }
                 gridDiv.appendChild(cellDiv);
              }
           }
           container.appendChild(gridDiv)
      }

     function handleInput(event, row, col) {
             const value = parseInt(event.target.value) || 0;
             if (value > 0 && value < 10) {
                 const prevValue = game.grid[row][col];
                 game.clearMove(row, col, prevValue);
                 const move = game.makeMove(row, col, value);
                  if(!move){
                     messageContainer.textContent = "Invalid Move"
                      game.clearMove(row, col, value);
                   } else {
                     messageContainer.textContent = '';
                     checkIfSolved();
                   }
             } else if (value === 0) {
                 const prevValue = game.grid[row][col];
                 game.clearMove(row, col, prevValue);
                  messageContainer.textContent = '';
             } else {
                    event.target.value = '';
                 messageContainer.textContent = "Invalid Move"
             }

        renderSudoku()
     }

     function checkIfSolved() {
       if(game.isSolved()) {
        messageContainer.textContent = 'You Won!'
       }
     }

     function resetGame() {
         game.reset();
         messageContainer.textContent = '';
          renderSudoku();
     }

      renderSudoku();

const styleTag = document.createElement('style');
         styleTag.textContent = `
         .sudoku-grid {
              display: grid;
             grid-template-columns: repeat(9, 40px);
             border: 2px solid black;
              margin-bottom: 20px;
          }

         .sudoku-grid div {
              width: 40px;
             height: 40px;
             border: 1px solid lightgray;
            display: flex;
             justify-content: center;
             align-items: center;
              font-size: 20px;
          }

          .sudoku-grid div.box {
             border: 2px solid black;
          }
         input {
             width: 40px;
             height: 40px;
             font-size: 20px;
             text-align: center;
        }
         `;
          document.head.appendChild(styleTag);